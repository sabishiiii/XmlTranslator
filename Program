import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.fge.jsonschema.core.exceptions.ProcessingException;
import com.github.fge.jsonschema.main.JsonSchema;
import com.github.fge.jsonschema.main.JsonSchemaFactory;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class JsonPathComparator {
    public static void main(String[] args) {
        String sampleFilePath = "path/to/sample.json";
        String schemaFilePath = "path/to/schema.json";

        try {
            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode sampleJsonNode = objectMapper.readTree(new File(sampleFilePath));
            JsonNode schemaJsonNode = objectMapper.readTree(new File(schemaFilePath));

            boolean isPathEqual = compareJsonPaths(sampleJsonNode, schemaJsonNode);

            if (isPathEqual) {
                System.out.println("Validation passed.");
                String pojoOutputPath = "path/to/output/POJO.java";
                generateJsonPojo(sampleJsonNode, pojoOutputPath);
                System.out.println("JSON POJO file generated at: " + pojoOutputPath);
            } else {
                System.out.println("Validation failed. The JSON paths are different.");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static boolean compareJsonPaths(JsonNode sampleJsonNode, JsonNode schemaJsonNode) {
        try {
            JsonSchemaFactory schemaFactory = JsonSchemaFactory.byDefault();
            JsonNode resolvedSchemaJsonNode = resolveReferences(schemaJsonNode);
            JsonSchema schema = schemaFactory.getJsonSchema(resolvedSchemaJsonNode);

            schema.validate(sampleJsonNode); // This will throw an exception if the validation fails

            return true; // If no exception is thrown, the paths are equal
        } catch (ProcessingException e) {
            return false; // Validation failed, the paths are different
        }
    }

    private static JsonNode resolveReferences(JsonNode schemaJsonNode) {
        Map<String, JsonNode> resolvedRefs = new HashMap<>();
        return resolveReferencesRecursive(schemaJsonNode, resolvedRefs);
    }

    private static JsonNode resolveReferencesRecursive(JsonNode jsonNode, Map<String, JsonNode> resolvedRefs) {
        if (jsonNode.isObject()) {
            JsonNode refNode = jsonNode.get("$ref");
            if (refNode != null && refNode.isTextual()) {
                String ref = refNode.textValue();
                if (resolvedRefs.containsKey(ref)) {
                    return resolvedRefs.get(ref);
                } else {
                    // Resolve the reference recursively
                    JsonNode resolvedRef = resolveReferencesRecursive(findReferencedNode(ref, jsonNode), resolvedRefs);
                    resolvedRefs.put(ref, resolvedRef);
                    return resolvedRef;
                }
            }

            // Recursively resolve references in object properties
            for (JsonNode child : jsonNode) {
                ((ObjectNode) jsonNode).set(child.fieldName(), resolveReferencesRecursive(child, resolvedRefs));
            }
        } else if (jsonNode.isArray()) {
            // Recursively resolve references in array elements
            for (JsonNode child : jsonNode) {
                resolveReferencesRecursive(child, resolvedRefs);
            }
        }

        return jsonNode;
    }

    private static JsonNode findReferencedNode(String ref, JsonNode schemaJsonNode) {
        String[] refParts = ref.split("#/");
        if (refParts.length != 2 || !refParts[0].isEmpty()) {
            throw new IllegalArgumentException("Invalid reference: " + ref);
        }

        String[] pathParts = refParts[1].split("/");
        JsonNode current = schemaJsonNode;

        for (String part : pathParts) {
            if (current.isObject()) {
                current = current.get(part);
            } else {
                throw new IllegalArgumentException("Invalid reference path: " + ref);
            }
        }

        return current;
    }

    private static void generateJsonPojo(JsonNode jsonNode, String outputPath) {
        try (FileWriter fileWriter = new FileWriter(outputPath)) {
            StringBuilder stringBuilder = new StringBuilder();

            // Generate package declaration
            stringBuilder.append("package com.example.pojo;\n\n");

            // Generate class declaration
            stringBuilder.append("public class POJO {\n\n");

            // Generate fields
            generateFields(jsonNode, stringBuilder);

            // Generate getters and setters
            generateGettersAndSetters(jsonNode, stringBuilder);

            // Close class
            stringBuilder.append("}\n");

            // Write to file
            fileWriter.write(stringBuilder.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void generateFields(JsonNode jsonNode, StringBuilder stringBuilder) {
        if (jsonNode.isObject()) {
            for (Map.Entry<String, JsonNode> entry : jsonNode.fields()) {
                String fieldName = entry.getKey();
                JsonNode fieldValue = entry.getValue();

                String fieldType = getFieldType(fieldValue);

                // Generate field declaration
                stringBuilder.append("    private ").append(fieldType).append(" ").append(fieldName).append(";\n");
            }

            stringBuilder.append("\n");
        }
    }

    private static String getFieldType(JsonNode fieldValue) {
        if (fieldValue.isTextual()) {
            return "String";
        } else if (fieldValue.isInt()) {
            return "int";
        } else if (fieldValue.isBoolean()) {
            return "boolean";
        } else if (fieldValue.isObject()) {
            return fieldValue.get("type").textValue(); // Assuming the "type" field exists in the schema
        } else {
            return "Object";
        }
    }

    private static void generateGettersAndSetters(JsonNode jsonNode, StringBuilder stringBuilder) {
        if (jsonNode.isObject()) {
            for (Map.Entry<String, JsonNode> entry : jsonNode.fields()) {
                String fieldName = entry.getKey();
                JsonNode fieldValue = entry.getValue();

                String fieldType = getFieldType(fieldValue);
                String capitalizedFieldName = capitalizeFirstLetter(fieldName);

                // Generate getter
                stringBuilder.append("    public ").append(fieldType).append(" get").append(capitalizedFieldName)
                        .append("() {\n");
                stringBuilder.append("        return ").append(fieldName).append(";\n");
                stringBuilder.append("    }\n\n");

                // Generate setter
                stringBuilder.append("    public void set").append(capitalizedFieldName).append("(")
                        .append(fieldType).append(" ").append(fieldName).append(") {\n");
                stringBuilder.append("        this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
                stringBuilder.append("    }\n\n");
            }
        }
    }

    private static String capitalizeFirstLetter(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}
